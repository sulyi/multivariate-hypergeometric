#/usr/bin/env python
#coding: UTF-8

'''
Combinatoric enumeration of the events of multivariate hypergeometric distribution   
and calculating their probabilities

Created on 2013.07.06.

@author: Ákos Sülyi
'''

import scipy.sparse

class Drawing(list):
    ''''
    event happened by drawing one element from an urn
    '''
    
    def __init__( self, iterable, gamma=0, delta=0):
        super( Drawing, self ).__init__( iterable )
        self.gamma = gamma
        self.delta = delta
        
    def __str__( self ):
        return '%s ~ (%d, %d)' % ( super( Drawing, self ).__repr__(),
                                   self.gamma,
                                   self.delta
                                 )
    
    def __repr__( self ):
        return 'Drawing( %s, %s, %s )' % ( super( Drawing, self ).__repr__(),
                                           self.gamma.__repr__(),
                                           self.delta.__repr__()
                                         )
                
class Pretty( list ):
    '''overriding output string formats'''

    def __init__( self, iterable=[] ):
        super( Pretty, self ).__init__( iterable )
        
    def __str__( self, depth=1 ):
        return '[ %s ]' %  (',\n' + '  ' * depth).join( i.__str__(depth+1) if isinstance(i, Pretty) else str(i) for i in self )
   
    def __repr__( self, depth=1 ):
        return 'Pretty([ %s\n%s])' %  ( (',\n' + ' '*9*depth).join( i.__repr__(depth+1) if isinstance(i, Pretty) else repr (i) for i in self ), ' '*(9*depth-2) )

class Level( Pretty ):
    '''a enumeration of Drawing with same amount drawn from them, hence sum of elements in the categories are constant
       root Level should be initialized with an iterable containing a single base Drawing and [ 1 ] twmatrix or without any
       other Levels should be generated by next_level method
       a value of twmatrix is the conditional probability of a Drawing of the next Level to occur if another from the current Level is known to occur
       each row belongs to the element with the corresponding index in the current Level
       each column belong to the element with corresponding index in the next level
       tw stands for transition weight 
    '''
    
    def __init__( self, iterable=[], twmatrix=None ):
        # fractional data type would be be swell as far as numeric stability goes,
        # but again that would make numerator and denominator of a product of matrices grow fractionally
          
        if not all( isinstance( e, Drawing ) for e in iterable ):
            raise ValueError( 'a Level may only contain Drawing' )
        
        super( Level, self ).__init__( iterable )
        
        if iterable:
            if twmatrix is not None:
                if twmatrix.shape[1] == len( iterable ):
                    self.twmatrix = twmatrix
                else:
                    raise ValueError( 'number of Drawing (%d) does not equal to number of columns of twmatrix (%d)' % ( twmatrix.shape[0], len(iterable) ))
            else:
                # I don't think this has any sense unless len(iterable) is one 
                self.twmatrix = scipy.sparse.csr_matrix(scipy.ones(( 1, len(iterable) )))
        else:
            self.twmatrix = scipy.empty((0,0))
            
    
    # TODO: __str__ parse twmatrix, it can show which branch of the algorithm added the value / Drawing    
    # TODO: dia plugin, just another parser
     
    def next_level( self, reverse=False, denominator=None ):
        '''enumerates the next Level, draws one farther element from each Drawing
           also calculates it's twmatrix
        '''
        
        if self:
            if denominator:
                denominator = float(denominator)
            else:
                denominator = float( sum(self[0]) )
            following = list()
            drawptr = list(0 for i in range(len(self[0])))

            data=list()
            indices = list()
            indptr = list()
            
            indptr.append(len(indices))
            
            for d in self:
                if reverse:
                    d.reverse()
                num_of_0s = d.gamma - d.delta
                    
                for i,k in enumerate(d): 
                    
                    if i < d.gamma:
                        
                        if k:
                            indices.append(drawptr[i])
                            data.append(k)
                            drawptr[i] += 1
                        elif drawptr[i] < len(following) and following[drawptr[i]].delta >= d.delta:
                                drawptr[i] = len(following)
                    else:
                        
                        if k:
                            child = Drawing( d, i, i - num_of_0s)
                            child[i] -= 1
                            if reverse:
                                child.reverse()
                            indices.append(len(following))
                            data.append(k)
                            following.append(child)
                        else:
                            num_of_0s += 1
                        drawptr[ i ] = len(following)
                            
                if reverse:
                    d.reverse()
                indptr.append(len(indices))
            twm = scipy.sparse.csr_matrix(( scipy.array(data), scipy.array(indices), scipy.array(indptr) )) / denominator
            return Level( following, twm )
        
        else:
            raise ValueError("Nothing follows an empty Level.")


def calculate( base ):
    ''' enumerating all possible Drawing from base 
        and calculating transition weight matrices of Levels
        product of previous Levels' twmatrices gives the probabilities of each element of the Level
        base contains number of elements in each category   
    '''
    
    summa = sum( base )
    previouse = Level( [ Drawing(base) ] )
    lattice = Pretty()
    
    lattice.append( previouse )
        
    for l in range( summa, 0, -1 ):
        previouse = previouse.next_level( True, l )
        lattice.append( previouse )
         
    return lattice
