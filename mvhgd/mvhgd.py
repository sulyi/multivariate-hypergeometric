#/usr/bin/env python
#-*- coding: UTF-8 -*-

'''
Combinatoric enumeration of the events of multivariate hypergeometric distribution   
and calculating their probabilities

see also: doc at calculate method

Created on 2013.07.06.

@author: Ákos Sülyi
'''

import scipy.sparse
from math import factorial

nCik = lambda n,k: factorial( n+k-1 ) / factorial( k ) / factorial( n-1 )

class Drawing( list ):
    
    ''''
    an event happened by drawing elements from an urn containing elements falling under different categories,
    the number of drawn elements in each category is given by an iterable  
    gamma and delta variables are aiding the enumeration of these events
    '''
    
    def __init__( self, supremum, gamma=0, delta=0 ):
        if hasattr( supremum, "__iter__" ):
            super( Drawing, self ).__init__( supremum )
            self.gamma = gamma
            self.delta = delta
        else:
            raise ValueError( "supremum should have an __iter__ attribute" )

    def __eq__( self, other ):
        if isinstance( other, Drawing ):
            return  super( Drawing, self ).__eq__( other ) and self.gamma == other.gamma and self.delta == other.delta
        return False

    def __str__( self ):
        return '%s ~ (%d, %d)' % ( super( Drawing, self ).__repr__(),
                                   self.gamma,
                                   self.delta
                                 )
    
    def __repr__( self ):
        return 'Drawing( %s, %s, %s )' % ( super( Drawing, self ).__repr__(),
                                           self.gamma.__repr__(),
                                           self.delta.__repr__()
                                         )
                
class Pretty( list ):
    
    '''
    overriding output string formats
    '''

    def __init__( self, supremum=[] ):
        super( Pretty, self ).__init__( supremum )
        
    def __getslice__( self, i, j ):
        return Pretty( super( Pretty, self ).__getslice__(i,j) )

    def __setslice__( self, i, j, sequence ):
        return Pretty( super( Pretty, self ).__setslice__(i,j) )
 
    def __delslice__( self, i, j ):
        return Pretty( super( Pretty, self ).__delslice__(i,j) )

    def __str__( self, depth=1 ):
        return '[ %s ]' %  ( ',\n '+' ' * depth).join( i.__str__(depth+2) if isinstance(i, Pretty) else str(i) for i in self )
   
    def __repr__( self, depth=0 ):
        depth+=len(self.__class__.__name__)+2
        return '%s([ %s\n%s])' %  ( self.__class__.__name__, (',\n '+' '*depth).join( i.__repr__(depth) if isinstance(i, Pretty) else repr (i) for i in self ), ' '*(depth) )

class Level( Pretty ):
    
    '''
    a enumeration of Drawing with same amount drawn from the base, hence sum of elements in the categories are equal
    root Level should be initialized with an iterable containing a single base Drawing and [ 1 ] as twmatrix or without any twmatrix
    other Levels should be generated by next_level method
    the values of twmatrix are conditional probability and equal the probability of a Drawing from the current Level to occur if an event from the previouse Level is known to occur
    each row belong to the element with corresponding index in the current level
    each column belongs to the element with the corresponding index in the previouse Level
    tw stands for transition weight 
    '''
    
    def __init__( self, supremum=[], twmatrix=None ):
        # fractional data type would be be swell as far as numeric stability goes,
        # but again that would make numerator and denominator in products of matrices grow factorially
          
        if not all( isinstance( e, Drawing ) for e in supremum ):
            raise ValueError( 'a Level may only contain Drawing' )
        
        super( Level, self ).__init__( supremum )
        
        if supremum:
            if twmatrix is not None:
                if twmatrix.shape[0] == len( supremum ):
                    self.twmatrix = twmatrix
                else:
                    raise ValueError( 'number of Drawing (%d) does not equal to number of rows of twmatrix (%d)' % ( len(supremum), twmatrix.shape[0] ))
            else:
                # I don't think this has any sense unless len(supremum) = 1 
                self.twmatrix = scipy.sparse.csc_matrix( scipy.ones(( 1, len(supremum) )) )
        else:
            self.twmatrix = scipy.empty(( 0, 0 ))
            
     
    def next_level( self, target=None, denominator=None ):
        
        '''
        enumerates the next Level, draws one farther element from each Drawing
        target limits the enumeration to only those events from which the target is reachable
        also calculates next Level's twmatrix
        '''
        
        if self:
            if denominator:
                denominator = float( denominator )
            else:
                denominator = float( sum(self[0]) )
                
            following = Pretty() # list() when it's not debuged   
            drawptr = list( 0 for i in range(len(self[0])) )

            data = list()
            indices = list()
            indptr = [ 0 ]
            
            if target is None:
                # cloning zeros
                target = list(drawptr)
            
            for d in self:
                
                num_of_0s = d.gamma - d.delta
                    
                for i,k in enumerate(d): 
                    
                    if i >= d.gamma:
                        
                        if k  > target[i]:
                            child = Drawing( d, i, i-num_of_0s )
                            child[i] -= 1
                            indices.append( len(following) )
                            data.append( k )
                            following.append( child )
                        else:
                            num_of_0s += 1
                        drawptr [i] = len(following)
                    
                    else:
#                        debug =  len(following), drawptr[i] < len(following), drawptr[i] < len(following) and following[drawptr[i]].delta >= d.delta
                        if k > target[i]:
                            indices.append( drawptr[i] )
                            data.append(k)
                            drawptr[i] += 1
                        elif drawptr[i] < len(following) and following[drawptr[i]].delta >= d.delta:
                                drawptr[ i ] = len(following)                    
                            
                indptr.append( len(indices) )
            
            twm = scipy.sparse.csc_matrix(( scipy.array(data), scipy.array(indices), scipy.array(indptr) )) / denominator
            return Level( following, twm )
        
        else:
            raise ValueError( "Nothing follows an empty Level." )


def calculate( base, target=None ):
    
    '''
    enumerating all possible Drawing from base
    base contains number of elements in each category
    target limits the enumeration to only those from which the target is reachable    
    and calculating transition weight matrices of Levels
    product of twmatrices of previous Levels gives the probabilities of each Drawing of a Level
    
    see also: doc at Level
    '''
    
    roof = sum( base )
    floor = 0 if target is None else sum( target )
    
    previouse = Level( [ Drawing( base ) ] )
    
    yield previouse
        
    for l in range( roof, floor, -1 ):
        previouse = previouse.next_level( target, l )
        yield previouse

def produce_probabilities( base, target=None ):
    
    # TODO: doc produce
    
    lattice = list()
    p = scipy.array([1.0])
    
    for level in calculate( base, target ):
        p = level.twmatrix*p
        lattice.append(zip( map(list,level), p ))
        
    return lattice

def ordered_sum_of_subsets( iterable ):
    
    # TODO: doc, http://math.stackexchange.com/questions/89419/algorithm-wanted-enumerate-all-subsets-of-a-set-in-order-of-increasing-sums
    
    # FIXME: lose ordering input
    N = list( iterable )
    N.sort()
    
    S = [(0,0)]
    L = [[]]
    A = [ 0 for _i in range(len(N)) ]
    i = 0
    
    while any( a is not None for a in A):
        
        min_S = None
         
        for i,a in enumerate(A):
            if a is not None:
                curr_S = N[i]+S[a][1]
            else:
                continue
            if min_S > curr_S or min_S is None:
                min_S = curr_S
                i_ast = i
            elif  min_S == curr_S and S[a][0] < S[A[i_ast]][0]:
                i_ast = i
            
        L_new = list( L[A[i_ast]] )
        L_new.append(( i_ast, N[i_ast] ))
        L.append( L_new )
        S.append(( len(L_new), min_S ))
        
        A[i_ast]+=1
        
        # FIXME: lover indexed elements must be lover in value, leading to need of ordering input
        while not all(N[i_ast] >= n and j < i_ast for j,n  in L[A[i_ast]]):
            A[i_ast]+=1
            if A[i_ast] == len(S):
                A[i_ast] = None
                break

    return S
    
def pre_calculate_length_of_levels( iterable ):
    
    #TODO: doc calculate length
    
    m = len( iterable )
    s = sum( iterable ) + 1
    S = ordered_sum_of_subsets( iterable )
    members = 0
    l = []
    for n in range(s):
        while  n+1 > sum( S[members] ):
            members += 1
        l.append(sum(  (-1)**S[i][0]*nCik(m,n-sum(S[i])) for i in range(members) ))
    return l