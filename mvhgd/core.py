#/usr/bin/env python
#-*- coding: UTF-8 -*-

# TODO: review doc strings, check python giude lines
# TODO: doc module

'''
Created on 2014.08.19.    

@author:  Ákos Sülyi
'''

from math import factorial


nCik = lambda n,k: factorial( n + k - 1 ) / factorial( k ) / factorial( n - 1 )
nCk  = lambda n,k: factorial( n ) / factorial( k ) / factorial( n - k )

class Drawing( bytearray ):
    
    '''
    an event happened by drawing elements from an urn containing elements falling under different categories,
    the number of drawn elements in each category is given by an iterable
    '''
    __slots__=[ 'gamma', 'delta', 'P' ]
    
    def __init__( self, iterable=None, gamma=0, delta=0, P=1.0 ):
        if iterable is not None:
            try:
                super( Drawing, self ).__init__( map( int, iterable ) )
            except TypeError:
                raise TypeError, "itreable must support iteration"
            except ValueError:
                raise ValueError, "each item in iterable must be an integer in range(0, 256)"
        else:
            super( Drawing, self ).__init__( )
        self.gamma = gamma
        self.delta = delta
        # fractional data type for P would be be swell as far as numeric stability goes,
        # but again that would make values grow factorially in size
        self.P = P
    
    def __eq__( self, other ):
        if not isinstance( other, Drawing ):
            return False
        return  super( Drawing, self ).__eq__( other ) and self.gamma == other.gamma and self.delta == other.delta
        

    def __str__( self ):
        return '%s ~ (%d, %s) - %r' % ( list( self ),
                                        self.gamma,
                                        self.delta,
                                        self.P
                                      )
    
    def __repr__( self ):
        return 'Drawing( %s, %r, %r, %r )' % ( list( self ),
                                               self.gamma,
                                               self.delta,
                                               self.P 
                                             )

class Pretty( list ):
    
    '''
    overriding output string formats
    '''

    def __init__( self, iterable=[] ):
        super( Pretty, self ).__init__( iterable )
        
    def __getslice__( self, i, j ):
        return Pretty( super( Pretty, self ).__getslice__( i, j ) )

    def __setslice__( self, i, j, sequence ):
        return Pretty( super( Pretty, self ).__setslice__( i, j ) )
 
    def __delslice__( self, i, j ):
        return Pretty( super( Pretty, self ).__delslice__( i, j ) )

    def __str__( self, depth=1 ):
        return '[ %s ]' %  ( ',\n '+' ' * depth).join( i.__str__(depth+2) if isinstance( i, Pretty ) else str(i) for i in self )
   
    def __repr__( self, depth=0 ):
        depth+=len(self.__class__.__name__)+2
        return '%s([ %s\n%s])' %  ( self.__class__.__name__, (',\n '+' '*depth).join( i.__repr__(depth) if isinstance(i, Pretty) else repr (i) for i in self ), ' '*(depth) )


class Level( Pretty ):
    
    '''
    a enumeration of Drawing with same amount drawn from the base, hence sum of elements in the categories are equal
    root Level should be initialized with an iterable containing a single base Drawing and [ 1 ] as twmatrix or without any twmatrix
    other Levels should be generated by next_level method
    '''
    
    __slots__=[ 'parent' ]
    
    def __init__( self, parent, iterable=[] ):
        if not isinstance( parent, Grid ):
            raise TypeError( "a Level's parent must be a Grid" )  
          
        if not all( isinstance( e, Drawing ) for e in iterable ):
            raise TypeError( "a Level may only contain Drawing" )
         
        self.parent = parent
        super( Level, self ).__init__( iterable )
            
    @property
    def P( self ):
        for d in self:
            yield d.P
    
    def next_level( self, denominator=None, target=None ):
        
        '''
        enumerates the next Level,
        draws one farther element from each Drawing and calculates the probabilities of them  
        target limits the enumeration to only those events from which the target is reachable
        denominator can be given which equals to the number of the Level enumerated
        '''

        if denominator:
            denominator = denominator
        else:
            denominator = sum( self[0] )
        
        if target is None:
            target = list( 0 for i in range( self.parent.m ) )
        
        n =  self.parent.roof-denominator
        flush = [ None for i in range( self.parent.m ) ]
        drawptr = [ self.parent.combinatoric_length( n, i ) for i in range( 1, self.parent.m ) ]
        drawptr.append( 0 )
        
        following = Level( self.parent, [] )
        
        for i,d in enumerate( self ):
            num_of_0s = d.gamma - d.delta
            
            for k in range( d.gamma, self.parent.m ):
                flush[k-num_of_0s] = len( following )
                
                if d[k] > target[k]:
                    p = self[i].P * d[k]
                    drawptr[k] += 1
                    
                    for j,c in enumerate( d ):
                        if j != k and c < self.parent.root[j]:
                            if drawptr[j] > i:
                                p += self[drawptr[j]].P * (c+1)
                                drawptr[j] += 1
                            else:
                                x = self.parent.combinatoric_length( n + sum(d[:j]), j + 1 )
                                drawptr[j] = i + ( x if x else 1 )
                                p += self[drawptr[j]].P * (c+1)
                                drawptr[j] += 1

                    child = Drawing( d, k, k - num_of_0s, p / denominator )
                    child[k] -= 1
                    following.append( child )
                    
                else:
                    num_of_0s += 1
                
        for i,f in enumerate( flush ):
            if f is not None:
                self.parent.lentab[i].append( len( following ) - f )
        
        if following:
            return following
        else:
            raise ValueError( "Nothing follows an empty Level." )
        
    def combinatoric_next_level( self, n=None, target=None ):
        n = n or self.parent.roof-sum(self[0]) 
        
        target = target or [ 0 ] * self.parent.m
        
        following = Level( self.parent, [] )
        
        for d in self:
            for k in range( d.gamma, self.parent.m ):
                if d[k]  > target[k]:
                    d_list = list( d )
                    d_list[k] -= 1
                    P = reduce(lambda x,y: x*y, map( nCk, self.parent.root, d_list ), 1.0 / nCk( self.parent.roof, n) )
                    child = Drawing( d_list, k, k, P ) 
                    
                    following.append( child )
                    
        if following:
            return following
        else:
            raise ValueError( "Nothing follows an empty Level." )
    
class Grid ( Pretty ):
    
    # TODO: doc Grid
    
    __slots__ = [ 'root', 'm', 'roof', 'lentab', '_iroot', '__weekref__' ]
    
    def __init__( self, supremum ):
        try:
            self.root = Drawing(supremum)
            self.m = len(supremum)
            self.roof = sum(self.root)
            self.lentab = [ [1] for i in range(self.m) ]
            self._iroot = [ sum(self.root[:i]) for i in range(self.m)  ]
        except Exception as e:
            raise e
        
    def __repr__( self ):
        return "Grid(%r)" % self.root
    
    def __str__( self ):
        return "Grid instance with supremum of %s" % self.root
    
    def generate( self, target=None ):
        floor = 0 if target is None else sum( target )
        
        previouse = Level( self, [ self.root ] )
        yield previouse
    
        for n in range( self.roof, floor, -1 ):
            previouse = previouse.next_level( n )
            yield previouse
    
    def combinatoric_generate( self, target=None ):
        floor = 1 if target is None else self.root - sum( target )
        
        previouse = Level( self, [ self.root ] )
        yield previouse
    
        for n in range( floor, self.roof + 1 ):
            previouse = previouse.combinatoric_next_level(n)
            yield previouse
    
    def combinatoric_length( self, n, i ):
        return max( 0, self.lentab[i][n - self._iroot[i]] ) 
