from pretty import Pretty
from draw import Draw


class Level( Pretty ):
    
    """
    a enumeration of Draws with same amount drawn from the base, hence sum of elements in the categories are equal
    root Level should be initialized with an iterable containing a single base Draw
    other Levels should be generated by next_level method
    """
    
    __slots__ = [ 'parent' ]
    
    def __init__( self, parent, iterable=[] ):
        from grid import Grid
        
        if not isinstance( parent, Grid ):
            raise TypeError( "parent of Level should be Grid type it's %s instead" % type(Grid) )
          
        if not all( isinstance( d, Draw ) for d in iterable ):
            raise TypeError( "a Level may only contain Draw" )
         
        self.parent = parent
        super( Level, self ).__init__( iterable )
            
    @property
    def P( self ):
        return ( d.P for d in self )

    def next_level( self, denominator=None, target=None ):
        
        """
        enumerates the next Level,
        draws one farther element from each Draw and calculates the probabilities of them
        target limits the enumeration to only those events from which the target is reachable
        denominator can be given which equals to the number of the Levels already enumerated
        """

        denominator = denominator or sum( self[0] )
        target = target or [ 0 ] * self.parent.m
        
        n = self.parent.roof - denominator
        
        flush = [ None ] * self.parent.m 
        drawptr = [ self.parent._read_len_tab( n, i ) for i in range( 1, self.parent.m ) ]
        drawptr.append( 0 )
        
        following = Level( self.parent, [] )
        
        for i, d in enumerate( self ):
            num_of_0s = d.gamma - sum( x > 0 for x in d[:d.gamma] )

            for k in range( d.gamma, self.parent.m ):
                flush[ k - num_of_0s ] = len( following )

                # enumerating descendants
                if d[k] > target[k]:
                    p = d.P * d[k]
                    drawptr[k] += 1

                    # finding other ascendants
                    for j, c in enumerate( d ):
                        if j != k and c < self.parent.root[j]:
                            # stepping
                            if drawptr[j] > i:
                                p += self[drawptr[j]].P * (c + 1)
                                drawptr[j] += 1
                            # skipping
                            else:
                                drawptr[j] = i + ( self.parent._read_len_tab( n + sum(d[:j]), j + 1 ) or 1 )
                                p += self[drawptr[j]].P * (c + 1)
                                drawptr[j] += 1

                    child = Draw( d, k, p / denominator )
                    child[k] -= 1
                    following.append( child )
                    
                else:
                    num_of_0s += 1
                
        # storing length of shifted level of each fixed prefix sublattice
        for i, f in enumerate( flush ):
            if f is not None:
                self.parent._len_tab[i].append( len( following ) - f )
        
        if following:
            return following
        else:
            raise ValueError( "Nothing follows an empty Level." )