from draw import Draw


class Level( object ):

    """
    a enumeration of Draws with same amount drawn from the base, hence sum of elements in the categories are equal
    root Level should be initialized with an iterable containing a single base Draw
    other Levels should be generated by next_level method
    """
    
    __slots__ = [ 'algorithm', 'parent' ]
    
    def __init__( self, algorithm, parent, iterable=[] ):
        from grid import Grid
        
        if not isinstance( parent, Grid ):
            raise TypeError( "parent of Level should be Grid type it's %s instead" % type(parent) )
          
        if not all( isinstance( d, Draw ) for d in iterable ):
            raise TypeError( "a Level may only contain Draw" )

        self.algorithm = algorithm(parent, iterable)
            
    @property
    def P( self ):
        return ( d.P for d in self.algorithm )

    def next_level( self, n=None, target=None ):
        
        """
        enumerates the next Level,
        draws one farther element from each Draw and calculates the probabilities of them
        target limits the enumeration to only those events from which the target is reachable
        denominator can be given which equals to the number of the Levels already enumerated
        """

        n = n or self.algorithm.parent.roof - sum( self.algorithm[0] )
        target = target or [ 0 ] * self.algorithm.parent.m

        following = self.algorithm.next_level(n, target)

        if following:
            return following
        else:
            raise ValueError( "Nothing follows an empty Level." )

    def __str__( self ):
        return str( self.algorithm )

    def __repr__( self ):
        return repr( self.algorithm )

    def __len__( self ):
        return len( self.algorithm )

    def __getitem__( self, key ):
        if isinstance(key, slice):
            return self.algorithm.__getitem__( key )
        return self.algorithm.__getitem__( key )

    def __getslice__( self, i, j ):
        return self.algorithm.__getslice__( i, j )

    def __setslice__( self, i, j, sequence ):
        return self.algorithm.__setslice__( i, j, sequence )

    def __delslice__( self, i, j ):
        return self.algorithm.__delslice__( i, j )
