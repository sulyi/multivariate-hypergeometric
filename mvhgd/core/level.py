from pretty import Pretty
from case import Case


class Level( Pretty ):
    
    """
    a enumeration of Cases with same amount drawn from the base, hence sum of elements in the categories are equal
    root Level should be initialized with an iterable containing a single base Case
    other Levels should be generated by next_level method
    """
    
    __slots__ = [ 'parent' ]
    
    def __init__( self, parent, iterable=[] ):
        from grid import Grid
        
        if not isinstance( parent, Grid ):
            raise TypeError( "a Level's parent must be a Grid" )  
          
        if not all( isinstance( d, Case ) for d in iterable ):
            raise TypeError( "a Level may only contain Case" )
         
        self.parent = parent
        super( Level, self ).__init__( iterable )
            
    @property
    def P( self ):
        return (d.P for d in self)
    
    def next_level( self, denominator=None, target=None ):
        
        """
        enumerates the next Level,
        draws one farther element from each Case and calculates the probabilities of them  
        target limits the enumeration to only those events from which the target is reachable
        denominator can be given which equals to the number of the Levels already enumerated
        """

        denominator = denominator or sum( self[0] )
        target = target or [ 0 ] * self.parent.m
        
        n = self.parent.roof - denominator
        
        flush = [ None ] * self.parent.m 
        drawptr = [ self.parent.read_len_tab( n, i ) for i in range( 1, self.parent.m ) ]
        drawptr.append( 0 )
        
        following = Level( self.parent, [] )
        
        for i, d in enumerate( self ):
            num_of_0s = d.gamma - reduce( lambda s, x: s + 1 if x else s, d[:d.gamma], 0 )
            
            for k in range( d.gamma, self.parent.m ):
                flush[ k - num_of_0s ] = len( following )
                
                if d[k] > target[k]:
                    p = self[i].P * d[k]
                    drawptr[k] += 1
                    
                    for j, c in enumerate( d ):
                        if j != k and c < self.parent.root[j]:
                            if drawptr[j] > i:
                                p += self[drawptr[j]].P * (c + 1)
                                drawptr[j] += 1
                            else:
                                drawptr[j] = i + ( self.parent.read_len_tab( n + sum(d[:j]), j + 1 ) or 1 )
                                p += self[drawptr[j]].P * (c + 1)
                                drawptr[j] += 1

                    child = Case( d, k, p / denominator )
                    child[k] -= 1
                    following.append( child )
                    
                else:
                    num_of_0s += 1
                
        for i, f in enumerate( flush ):
            if f is not None:
                self.parent.len_tab[i].append( len( following ) - f )
        
        if following:
            return following
        else:
            raise ValueError( "Nothing follows an empty Level." )
